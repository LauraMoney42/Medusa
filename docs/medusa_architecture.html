<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Medusa Architecture</title>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <style>
    :root {
      --bg:           #0a0f0a;
      --surface:      #111711;
      --card:         #161e16;
      --border:       #1f2e1f;
      --green-dim:    #2d5a2d;
      --green:        #3a7a3a;
      --green-bright: #4caf50;
      --green-glow:   #66bb6a;
      --text:         #e8f5e9;
      --text-muted:   #8aab8a;
      --accent:       #00e676;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      line-height: 1.7;
      padding: 48px 24px;
      max-width: 1100px;
      margin: 0 auto;
    }

    /* ── Header ── */
    .page-header { text-align: center; margin-bottom: 56px; }
    .logo-ring {
      display: inline-flex; align-items: center; justify-content: center;
      width: 100px; height: 100px; border-radius: 50%;
      background: radial-gradient(circle at 40% 35%, #1a3a1a, #0a0f0a);
      border: 1.5px solid var(--green);
      box-shadow: 0 0 32px rgba(74,175,74,.3), inset 0 0 16px rgba(0,0,0,.6);
      margin-bottom: 20px;
      overflow: hidden;
    }
    .logo-ring img { width: 100%; height: 100%; object-fit: cover; }
    h1 {
      font-size: 2.4rem; font-weight: 700; letter-spacing: -.5px;
      background: linear-gradient(135deg, var(--green-glow) 0%, var(--accent) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .subtitle { margin-top: 10px; color: var(--text-muted); font-size: .95rem; }

    /* ── Section headings ── */
    h2 {
      font-size: 1.35rem; font-weight: 600; color: var(--green-glow);
      border-bottom: 1px solid var(--border);
      padding-bottom: 10px; margin: 48px 0 24px; letter-spacing: .2px;
    }
    h3 {
      font-size: .78rem; font-weight: 600; color: var(--text-muted);
      margin: 32px 0 12px; text-transform: uppercase; letter-spacing: 1px;
    }

    /* ── Cards ── */
    .card {
      background: var(--card); border: 1px solid var(--border);
      border-radius: 14px; padding: 28px 32px; margin-bottom: 24px;
      box-shadow: 0 2px 16px rgba(0,0,0,.4);
    }
    .card p { color: var(--text-muted); font-size: .95rem; }

    /* ── Diagram wrapper ── */
    .diagram-card {
      background: var(--card); border: 1px solid var(--border);
      border-radius: 14px; padding: 32px 24px; margin-bottom: 32px;
      overflow-x: auto; box-shadow: 0 2px 24px rgba(0,0,0,.45);
    }
    .diagram-card .diagram-title {
      font-size: .85rem; font-weight: 600; color: var(--green-bright);
      margin-bottom: 20px; text-transform: uppercase; letter-spacing: 1px;
    }
    .diagram-card .diagram-title span {
      color: #4a4a4a; font-weight: 400; font-size: .75rem;
      margin-left: 8px; text-transform: none; letter-spacing: 0;
    }
    .mermaid { display: flex; justify-content: center; }

    /* ── Two-col grid ── */
    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px; margin-bottom: 24px;
    }

    /* ── Tech pills ── */
    .stack-group { margin-bottom: 20px; }
    .stack-group h3 { margin-bottom: 10px; }
    .pills { display: flex; flex-wrap: wrap; gap: 8px; }
    .pill {
      background: var(--surface); border: 1px solid var(--green-dim);
      border-radius: 20px; padding: 4px 14px;
      font-size: .8rem; color: var(--green-bright);
      font-family: "SF Mono", "Fira Code", monospace;
    }

    /* ── Lists ── */
    ul { list-style: none; padding: 0; }
    ul li {
      padding: 5px 0 5px 18px; position: relative;
      color: var(--text-muted); font-size: .9rem;
    }
    ul li::before { content: "›"; position: absolute; left: 0; color: var(--green-bright); font-weight: 700; }
    ul li strong { color: var(--text); }

    /* ── Inline code ── */
    code {
      background: #0d160d; border: 1px solid var(--border); border-radius: 5px;
      padding: 1px 6px; font-family: "SF Mono","Fira Code",monospace;
      font-size: .82em; color: var(--accent);
    }

    /* ── Design decision cards ── */
    .reason-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 16px; }
    .reason-card {
      background: var(--surface); border: 1px solid var(--border);
      border-left: 3px solid var(--green); border-radius: 10px; padding: 18px 20px;
    }
    .reason-card h4 { font-size: .85rem; font-weight: 600; color: var(--green-bright); margin-bottom: 10px; }
    .reason-card ul li { font-size: .83rem; }

    /* ── Tables ── */
    table {
      width: 100%; border-collapse: collapse; margin: 12px 0;
      font-size: .85rem;
    }
    th {
      text-align: left; padding: 8px 12px;
      color: var(--green-bright); font-weight: 600;
      border-bottom: 1px solid var(--green-dim);
      font-size: .75rem; text-transform: uppercase; letter-spacing: .5px;
    }
    td {
      padding: 6px 12px; color: var(--text-muted);
      border-bottom: 1px solid rgba(31,46,31,.5);
    }
    td code { font-size: .78em; }

    hr { border: none; border-top: 1px solid var(--border); margin: 48px 0; }

    footer {
      text-align: center; color: var(--text-muted); font-size: .78rem;
      margin-top: 64px; padding-top: 24px; border-top: 1px solid var(--border);
    }
    footer a { color: var(--green-bright); text-decoration: none; }

    @media print {
      body { padding: 24px 16px; }
      h1 {
        background: none !important;
        -webkit-background-clip: unset !important;
        -webkit-text-fill-color: #e8f5e9 !important;
        background-clip: unset !important;
        color: #e8f5e9 !important;
      }
      .logo-ring { border: none !important; box-shadow: none !important; }
      .card, .diagram-card, .reason-card { box-shadow: none !important; break-inside: avoid; }
      h2 { break-after: avoid; }
    }
  </style>
</head>
<body>

<!-- HEADER -->
<div class="page-header">
  <div class="logo-ring">
    <img src="../client/public/MedusaIcon.png" alt="Medusa Logo" />
  </div>
  <h1>Medusa Architecture</h1>
  <p class="subtitle">Multi-bot AI Orchestration Platform — System Design Reference</p>
</div>

<!-- OVERVIEW -->
<div class="card">
  <p>Medusa is a multi-bot orchestration system that enables parallel execution of multiple Claude AI sessions with real-time coordination via a shared Hub. Bots communicate through <code>[HUB-POST:]</code> broadcasts and <code>[BOT-TASK:]</code> direct messages, self-assign tasks, auto-escalate blockers, and update project status — all coordinated through REST APIs and Socket.IO events.</p>
</div>

<!-- HIGH-LEVEL ARCHITECTURE -->
<h2>High-Level Architecture</h2>
<div class="diagram-card">
  <div class="diagram-title">System Overview — Client · Server · Bots · Storage · Desktop</div>
  <div class="mermaid" id="diagram-1">
graph TB
    subgraph Desktop["macOS Desktop App (Swift + WKWebView)"]
        ServerMgr[Server Manager<br/>Auto-build · Port cleanup]
        WebView[WKWebView<br/>Cookie auth · Screen capture]
    end

    subgraph Client["Client (React + TypeScript + Zustand)"]
        UI[UI Components]
        Sidebar[Sidebar · Bot List · Projects]
        HubUI[Hub Chat]
        SocketClient[Socket.IO Client]
    end

    subgraph Server["Server (Node.js + Express + Socket.IO)"]
        API[REST API<br/>Auth · Sessions · Hub · Projects · Settings]
        SocketServer[Socket.IO Server]
        ProcessMgr[Process Manager]
        MentionRouter[Mention Router<br/>@name · @all · BOT-TASK]
        PollScheduler[Hub Poll Scheduler<br/>Stale detection · Hibernation]
        ModelRouter[Model Router<br/>haiku · sonnet · opus]
        Summarizer[Conversation Summarizer]
        TaskSync[Task Sync Manager<br/>Fuzzy match · Auto-update]
        SettingsStore[Settings Store<br/>Multi-account · LLM config]
        AutoDeliver[Autonomous Deliver<br/>Unified streaming pipeline]
        Shutdown[Graceful Shutdown<br/>Auto-resume on restart]
    end

    subgraph Bots["Claude CLI Bot Sessions"]
        Bot1["Bot 1<br/>(e.g. Product Manager)"]
        Bot2["Bot 2<br/>(e.g. Full Stack Dev)"]
        BotN["Bot N<br/>(e.g. UI Dev)"]
    end

    subgraph Storage["File System (~/.claude-chat/)"]
        Sessions[sessions.json]
        HubLog[hub.json]
        Projects[projects.json]
        Settings[settings.json<br/>chmod 600]
        ChatFiles[chats/*.json]
        Interrupted[interrupted-sessions.json]
    end

    ServerMgr -->|spawns & monitors| Server
    WebView -->|httpOnly cookie| Client

    UI --> SocketClient
    SocketClient <-->|WebSocket| SocketServer
    UI -->|fetch| API

    SocketServer --> ProcessMgr
    ProcessMgr --> Bot1
    ProcessMgr --> Bot2
    ProcessMgr --> BotN

    Bot1 -->|"[HUB-POST:] [BOT-TASK:]"| MentionRouter
    Bot2 -->|"[HUB-POST:] [BOT-TASK:]"| MentionRouter
    MentionRouter -->|"@mention delivery"| AutoDeliver
    AutoDeliver --> ProcessMgr

    PollScheduler -->|"periodic check"| AutoDeliver
    ModelRouter -.->|"tier selection"| ProcessMgr
    Summarizer -.->|"compress history"| ChatFiles
    TaskSync -.->|"[TASK-DONE:] → update"| Projects

    API --> SettingsStore
    SettingsStore --> Settings
    ProcessMgr --> ChatFiles
    MentionRouter --> HubLog
    Shutdown -.->|"save state"| Interrupted
  </div>
</div>

<!-- BOT COMMUNICATION -->
<h2>Bot-to-Bot Communication</h2>

<div class="card">
  <h3>Two Communication Protocols</h3>
  <p>Bots communicate through two distinct marker protocols, both detected inline during streaming output:</p>
  <ul>
    <li><strong><code>[HUB-POST: message]</code></strong> — Public broadcast to Hub. Visible to all clients. Stored in hub.json. Routes @mentions to target bots. Triggers <code>[TASK-DONE:]</code> detection.</li>
    <li><strong><code>[BOT-TASK: @BotName message]</code></strong> — Private direct message. NOT visible in Hub. NOT stored. Routes directly to target bot via MentionRouter. Used for bot-to-bot task delegation without Hub noise.</li>
  </ul>
</div>

<div class="diagram-card">
  <div class="diagram-title">Hub Message + @Mention Flow</div>
  <div class="mermaid" id="diagram-2">
sequenceDiagram
    participant User
    participant Client
    participant Server
    participant MentionRouter
    participant Bot1 as Bot A
    participant Bot2 as Bot B

    User->>Client: Types message in Hub
    Client->>Server: socket emit hub:post
    Server->>Server: Store in hub.json
    Server-->>Client: broadcast hub:message
    Server->>MentionRouter: extractMentions(@BotB)

    MentionRouter->>MentionRouter: Check guards<br/>(cooldown, queue depth, chain depth)
    alt Bot B idle
        MentionRouter->>Bot2: autonomousDeliver(source: mention)
    else Bot B busy
        MentionRouter->>MentionRouter: Queue (max 3 pending)
        Note over MentionRouter: Drains on session:idle
    end

    Bot2->>Server: [HUB-POST: response with @BotA]
    Server->>Server: Strip marker, store in hub.json
    Server-->>Client: broadcast hub:message
    Server->>MentionRouter: Route @BotA (chain depth +1)
    MentionRouter->>Bot1: autonomousDeliver(source: mention)
    Note over MentionRouter: Max chain depth: 3
  </div>
</div>

<div class="diagram-card">
  <div class="diagram-title">BOT-TASK Direct Routing <span>(invisible to Hub)</span></div>
  <div class="mermaid" id="diagram-3">
sequenceDiagram
    participant Bot1 as Bot A (PM)
    participant Server
    participant MentionRouter
    participant Bot2 as Bot B (Dev)

    Bot1->>Server: [BOT-TASK: @BotB implement feature X]
    Server->>Server: Strip marker from stream<br/>(NOT stored in Hub)
    Server->>MentionRouter: processBotTaskContent()
    MentionRouter->>MentionRouter: Resolve @BotB name<br/>(longest-first match)
    MentionRouter->>Bot2: autonomousDeliver(source: bot-to-bot)
    Bot2->>Server: [HUB-POST: @BotA done, feature X complete]
    Server->>Server: Store in hub.json
    Server-->>Bot1: Next system prompt includes Hub update
    Bot2->>Server: [TASK-DONE: Implemented feature X]
    Server->>Server: TaskSyncManager fuzzy-match<br/>(Jaccard ≥ 0.6)
    Server->>Server: Auto-update project assignment → done
  </div>
</div>

<!-- AUTONOMOUS DELIVERY PIPELINE -->
<h2>Autonomous Delivery Pipeline</h2>

<div class="card">
  <p>All bot-initiated message delivery flows through a unified <code>autonomousDeliver()</code> pipeline. This replaced 4 separate streaming implementations with a single, consistent path.</p>
  <table>
    <tr><th>Source</th><th>Compact Hub</th><th>Detect Hub Posts</th><th>Persist User Msg</th><th>Check NO-ACTION</th><th>Trigger</th></tr>
    <tr><td><code>mention</code></td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>@BotName in Hub</td></tr>
    <tr><td><code>poll</code></td><td>Yes</td><td>Yes</td><td>Deferred</td><td>Yes</td><td>Scheduled hub check</td></tr>
    <tr><td><code>nudge</code></td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>Stale task escalation</td></tr>
    <tr><td><code>resume</code></td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>Server restart recovery</td></tr>
    <tr><td><code>bot-to-bot</code></td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>[BOT-TASK:] marker</td></tr>
  </table>
</div>

<!-- MODEL ROUTING -->
<h2>Tiered Model Routing</h2>
<div class="card">
  <p>Every message is classified into a model tier before sending to Claude CLI. On failure, auto-escalates to the next tier (haiku → sonnet → opus).</p>
  <table>
    <tr><th>Tier</th><th>When Used</th><th>Cost</th></tr>
    <tr><td><code>haiku</code></td><td>Poll checks, nudges, status queries, acknowledgments, [NO-ACTION]</td><td>Lowest</td></tr>
    <tr><td><code>sonnet</code></td><td>@mention responses, general user messages (default)</td><td>Medium</td></tr>
    <tr><td><code>opus</code></td><td>Architecture, design, code review, security audit, RFC</td><td>Highest</td></tr>
  </table>
</div>

<hr/>

<!-- DATA FLOW -->
<h2>Message Processing Flow</h2>

<div class="diagram-card">
  <div class="diagram-title">User Message → Bot Response Pipeline</div>
  <div class="mermaid" id="diagram-4">
graph TB
    A["User sends message"] --> B["handler.ts receives socket event"]
    B --> C["Build system prompt:<br/>session prompt + skills<br/>+ conversation summary<br/>+ Hub section (last 20 msgs)"]
    C --> D["selectModel() → tier"]
    D --> E["ProcessManager.sendMessage()<br/>claude -p ... --resume --model tier"]
    E --> F["StreamParser (NDJSON)"]
    F --> G["HubPostDetector on each delta"]
    G --> H{Marker detected?}
    H -->|"[HUB-POST:]"| I["Store in hub.json<br/>Broadcast to clients<br/>Route @mentions<br/>Check TASK-DONE"]
    H -->|"[BOT-TASK:]"| J["Route to target bot<br/>via MentionRouter<br/>(not stored in Hub)"]
    H -->|Clean text| K["emit message:stream:delta"]
    I --> K
    J --> K
    K --> L["Stream end"]
    L --> M["Persist to chat history"]
    M --> N{"Messages ≥ 30?"}
    N -->|Yes| O["Summarize with haiku<br/>Trim to last 5 messages"]
    N -->|No| P["emit session:status idle"]
    O --> P
    P --> Q["MentionRouter.onSessionIdle()<br/>Drain pending queue"]
  </div>
</div>

<div class="diagram-card">
  <div class="diagram-title">Graceful Shutdown + Auto-Resume</div>
  <div class="mermaid" id="diagram-5">
sequenceDiagram
    participant Trigger as SIGTERM / POST /shutdown
    participant Server
    participant ProcessMgr
    participant Storage
    participant Bots

    Trigger->>Server: Initiate shutdown
    Server->>Server: Stop accepting connections
    Server->>Server: Stop PollScheduler
    Server-->>Server: emit server:shutting-down
    loop Every 500ms up to 30s
        Server->>ProcessMgr: getBusySessions()
        alt All idle
            Server->>Server: Clean exit (code 0)
        else Timeout
            Server->>ProcessMgr: Kill all sessions
            ProcessMgr->>Storage: Write interrupted-sessions.json
            Server->>Server: Force exit
        end
    end

    Note over Server: On next startup (1s after listen)
    Server->>Storage: Read interrupted-sessions.json
    Server->>Storage: Delete file immediately
    loop For each interrupted session
        Server->>Bots: autonomousDeliver(source: resume)
        Server->>Server: Hub post "Resuming work for BotName"
    end
  </div>
</div>

<hr/>

<!-- REST API -->
<h2>REST API Endpoints</h2>

<div class="grid-2">
  <div class="card">
    <h3>Auth</h3>
    <ul>
      <li><code>POST /api/auth/login</code> — Validate token, set httpOnly cookie</li>
      <li><code>POST /api/auth/logout</code> — Clear cookie</li>
      <li><code>GET /api/auth/me</code> — Check if authenticated</li>
    </ul>
  </div>
  <div class="card">
    <h3>Sessions</h3>
    <ul>
      <li><code>GET /api/sessions</code> — List all bot sessions</li>
      <li><code>POST /api/sessions</code> — Create session</li>
      <li><code>PATCH /api/sessions/:id</code> — Rename / update prompt</li>
      <li><code>DELETE /api/sessions/:id</code> — Delete + cleanup</li>
      <li><code>PUT /api/sessions/reorder</code> — Reorder list</li>
      <li><code>POST /api/sessions/bulk-prompt-append</code> — Deploy protocol updates to all bots</li>
    </ul>
  </div>
</div>

<div class="grid-2">
  <div class="card">
    <h3>Hub</h3>
    <ul>
      <li><code>GET /api/hub</code> — All hub messages</li>
      <li><code>POST /api/hub</code> — Post to Hub (REST — bots, CLI, external tools)</li>
      <li><code>GET /api/hub/tasks</code> — Unacknowledged completed tasks</li>
      <li><code>POST /api/hub/tasks/ack</code> — Acknowledge all tasks</li>
    </ul>
  </div>
  <div class="card">
    <h3>Projects</h3>
    <ul>
      <li><code>GET /api/projects</code> — List projects (summary)</li>
      <li><code>GET /api/projects/:id</code> — Full project detail</li>
      <li><code>POST /api/projects</code> — Create project</li>
      <li><code>PATCH /api/projects/:id</code> — Update project</li>
      <li><code>DELETE /api/projects/:id</code> — Delete project</li>
    </ul>
  </div>
</div>

<div class="grid-2">
  <div class="card">
    <h3>Settings</h3>
    <ul>
      <li><code>GET /api/settings</code> — Current settings (key masked)</li>
      <li><code>PATCH /api/settings</code> — Update LLM provider / API key</li>
      <li><code>POST /api/settings/account</code> — Switch active account</li>
      <li><code>GET /api/settings/login-status</code> — Check Claude CLI login per account</li>
      <li><code>POST /api/settings/account/:id/login</code> — OAuth login</li>
      <li><code>POST /api/settings/account/:id/logout</code> — Logout</li>
    </ul>
  </div>
  <div class="card">
    <h3>System</h3>
    <ul>
      <li><code>GET /api/health</code> — Health check (no auth)</li>
      <li><code>POST /api/health/shutdown</code> — Graceful shutdown</li>
      <li><code>GET /api/skills</code> — Available skills catalog</li>
      <li><code>POST /api/images</code> — Upload image (max 20MB)</li>
      <li><code>GET /api/chat/:id/messages</code> — Chat history</li>
      <li><code>GET /api/caffeine/status</code> — Caffeinate status</li>
      <li><code>POST /api/caffeine/enable</code> — Prevent Mac sleep</li>
      <li><code>POST /api/caffeine/disable</code> — Allow Mac sleep</li>
    </ul>
  </div>
</div>

<hr/>

<!-- SOCKET.IO EVENTS -->
<h2>Socket.IO Events</h2>

<div class="grid-2">
  <div class="card">
    <h3>Client → Server</h3>
    <ul>
      <li><code>message:send</code> — Send message to bot (text + images)</li>
      <li><code>message:abort</code> — Kill running Claude process</li>
      <li><code>hub:post</code> — Post to Hub</li>
      <li><code>session:join</code> / <code>session:leave</code> — Room management</li>
      <li><code>session:toggle-yolo</code> — Toggle skip-permissions</li>
      <li><code>session:set-yolo</code> — Set skip-permissions explicitly</li>
      <li><code>session:update-system-prompt</code></li>
      <li><code>session:update-skills</code></li>
      <li><code>session:update-working-dir</code></li>
    </ul>
  </div>
  <div class="card">
    <h3>Server → Client</h3>
    <ul>
      <li><code>message:stream:start</code> / <code>delta</code> / <code>end</code> — Streaming response</li>
      <li><code>message:stream:tool</code> / <code>tool_result</code> — Tool use</li>
      <li><code>message:error</code> — Stream error</li>
      <li><code>message:user</code> — Echo user message</li>
      <li><code>session:status</code> — busy/idle state</li>
      <li><code>session:pending-task</code> — Queued mention badge</li>
      <li><code>hub:message</code> — Hub broadcast</li>
      <li><code>task:done</code> — Task completed</li>
      <li><code>projects:updated</code> — File watcher change</li>
      <li><code>server:shutting-down</code> — Shutdown notice</li>
    </ul>
  </div>
</div>

<hr/>

<!-- MENTION ROUTER GUARDS -->
<h2>Mention Router — Safety Guards</h2>
<div class="card">
  <table>
    <tr><th>Guard</th><th>Behavior</th></tr>
    <tr><td><strong>Self-mention</strong></td><td>Dropped silently (prevents loops)</td></tr>
    <tr><td><strong>Max queue depth</strong></td><td>3 pending mentions per bot (4th+ silently dropped)</td></tr>
    <tr><td><strong>Cooldown</strong></td><td>60 seconds between deliveries to same bot</td></tr>
    <tr><td><strong>Chain depth</strong></td><td>Max 3 hops (Bot A → Bot B → Bot C → stop)</td></tr>
    <tr><td><strong>@all broadcast</strong></td><td>Pings every session except the sender</td></tr>
    <tr><td><strong>Name resolution</strong></td><td>Sorted longest-first to prevent partial matches (e.g. "UI Dev" before "Dev")</td></tr>
  </table>
</div>

<hr/>

<!-- HUB POLL SCHEDULER -->
<h2>Hub Poll Scheduler</h2>
<div class="card">
  <p>Background scheduler that periodically nudges idle bots to check the Hub for new messages. Enabled via <code>HUB_POLLING=true</code>.</p>
  <ul>
    <li><strong>Poll interval:</strong> 2 minutes (configurable)</li>
    <li><strong>Per-bot cooldown:</strong> 10 minutes</li>
    <li><strong>Max bots per tick:</strong> 4</li>
    <li><strong>New message filtering:</strong> Only polls if new Hub messages since last check</li>
    <li><strong>Hibernation:</strong> Bots with no pending tasks only wake for direct @mentions or @all</li>
    <li><strong>Stale detection:</strong> If a bot has a pending task for 10+ minutes, posts System warning to Hub and sends a nudge</li>
    <li><strong>[NO-ACTION]:</strong> Empty check-in responses silently discarded (no chat history entry)</li>
  </ul>
</div>

<hr/>

<!-- SETTINGS + MULTI-ACCOUNT -->
<h2>Settings &amp; Multi-Account</h2>
<div class="card">
  <p>Two Claude accounts with separate <code>CLAUDE_CONFIG_DIR</code> paths. API key stored locally with chmod 600 protection and masked in all API responses.</p>
  <ul>
    <li><strong>Account switching:</strong> Affects <code>CLAUDE_CONFIG_DIR</code> for new bot messages only</li>
    <li><strong>Login status:</strong> Runs <code>claude auth status --json</code> per account (handles exit code 1)</li>
    <li><strong>Login/logout:</strong> Runs <code>claude auth login</code> / <code>claude auth logout</code> with correct config dir</li>
    <li><strong>LLM provider:</strong> <code>claude</code> or <code>openai</code> (stored in settings.json)</li>
    <li><strong>API key masking:</strong> Only last 4 chars returned to clients (<code>sk-...abcd</code>)</li>
  </ul>
</div>

<hr/>

<!-- DESKTOP APP -->
<h2>macOS Desktop App</h2>
<div class="card">
  <p>Native Swift/SwiftUI wrapper that manages the full server lifecycle.</p>
  <ul>
    <li><strong>ServerManager:</strong> Finds Node/npm, auto-builds client + server if missing, spawns <code>node dist/index.js</code>, polls <code>/api/health</code> for readiness</li>
    <li><strong>WebViewController:</strong> WKWebView with httpOnly cookie injection (no login screen), loading overlay with spinner</li>
    <li><strong>Port cleanup:</strong> Kills stale processes on port 3456 at startup</li>
    <li><strong>Screen capture:</strong> Native macOS ScreenCaptureKit overlays — full screen (SC4), window picker (SC5), region select (SC6)</li>
    <li><strong>JS bridge:</strong> <code>window.webkit.messageHandlers.captureScreen.postMessage()</code> → Swift → <code>CustomEvent('medusaNativeCapture')</code></li>
  </ul>
</div>

<hr/>

<!-- TECH STACK -->
<h2>Technical Stack</h2>
<div class="grid-2">
  <div class="card">
    <div class="stack-group">
      <h3>Client</h3>
      <div class="pills">
        <span class="pill">React 18</span><span class="pill">TypeScript</span>
        <span class="pill">Zustand</span><span class="pill">Socket.IO Client</span>
        <span class="pill">Vite</span>
      </div>
    </div>
    <div class="stack-group" style="margin-top:20px">
      <h3>Server</h3>
      <div class="pills">
        <span class="pill">Node.js</span><span class="pill">Express</span>
        <span class="pill">Socket.IO</span><span class="pill">TypeScript</span>
        <span class="pill">Zod</span>
      </div>
    </div>
  </div>
  <div class="card">
    <div class="stack-group">
      <h3>Desktop</h3>
      <div class="pills">
        <span class="pill">Swift</span><span class="pill">SwiftUI</span>
        <span class="pill">WKWebView</span><span class="pill">ScreenCaptureKit</span>
      </div>
    </div>
    <div class="stack-group" style="margin-top:20px">
      <h3>AI + Storage</h3>
      <div class="pills">
        <span class="pill">Claude CLI</span><span class="pill">haiku</span><span class="pill">sonnet</span><span class="pill">opus</span>
        <span class="pill">JSON files</span><span class="pill">No database</span>
      </div>
    </div>
  </div>
</div>

<hr/>

<!-- KEY DESIGN DECISIONS -->
<h2>Key Design Decisions</h2>
<div class="reason-grid">
  <div class="reason-card">
    <h4>File-Based Storage</h4>
    <ul>
      <li>No database setup required</li>
      <li>Human-readable JSON + Markdown</li>
      <li>Git-friendly version history</li>
      <li>Right-sized for 5–15 bots</li>
    </ul>
  </div>
  <div class="reason-card">
    <h4>Socket.IO Over REST Polling</h4>
    <ul>
      <li>Real-time Hub + status updates</li>
      <li>Low-latency task assignment</li>
      <li>Bidirectional server push</li>
      <li>Token-by-token streaming</li>
    </ul>
  </div>
  <div class="reason-card">
    <h4>Process-per-Bot Isolation</h4>
    <ul>
      <li>Each bot crash is isolated</li>
      <li>Claude CLI is a CLI tool, not a lib</li>
      <li>OS-level resource management</li>
      <li>Easy per-process debugging</li>
    </ul>
  </div>
  <div class="reason-card">
    <h4>Dual Protocol (HUB-POST + BOT-TASK)</h4>
    <ul>
      <li>HUB-POST = public coordination</li>
      <li>BOT-TASK = private delegation</li>
      <li>Reduces Hub noise for direct tasks</li>
      <li>Both detected inline during streaming</li>
    </ul>
  </div>
  <div class="reason-card">
    <h4>Tiered Model Routing</h4>
    <ul>
      <li>Haiku for cheap status checks</li>
      <li>Sonnet for standard work</li>
      <li>Opus for architecture decisions</li>
      <li>Auto-escalation on failure</li>
    </ul>
  </div>
  <div class="reason-card">
    <h4>Conversation Summarization</h4>
    <ul>
      <li>Compress at 30 messages</li>
      <li>Haiku one-shot (under 200 words)</li>
      <li>Trim to last 5 + summary</li>
      <li>Prevents context overflow</li>
    </ul>
  </div>
</div>

<hr/>

<!-- SECURITY -->
<h2>Security</h2>
<div class="card">
  <ul>
    <li><strong>httpOnly cookie auth</strong> — Token never accessible to JavaScript</li>
    <li><strong>Rate limiting</strong> — 5 login attempts/15min, 500 API req/15min, 100 uploads/hr</li>
    <li><strong>API key protection</strong> — settings.json chmod 600, keys masked in all responses</li>
    <li><strong>CORS</strong> — Restricted to configured origins only</li>
    <li><strong>Socket auth</strong> — Cookie or Bearer token required on every connection</li>
    <li><strong>Process sandboxing</strong> — Bots run in Claude CLI sandbox by default (YOLO mode opt-in per session)</li>
    <li><strong>.env secrets</strong> — Gitignored, never committed</li>
  </ul>
</div>

<!-- FOOTER -->
<footer>
  Built by <a href="https://www.linkedin.com/in/lauramoney/" target="_blank">Laura Money</a> at
  <a href="https://kindcode.ai" target="_blank">KindCode</a> &nbsp;·&nbsp; Medusa Architecture v2.0
</footer>

<script>
  mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    securityLevel: 'loose',
    themeVariables: {
      darkMode: true,
      background:           '#111711',
      mainBkg:              '#161e16',
      nodeBorder:           '#3a7a3a',
      clusterBkg:           '#0d160d',
      clusterBorder:        '#2d5a2d',
      titleColor:           '#e8f5e9',
      edgeLabelBackground:  '#0a0f0a',
      lineColor:            '#4caf50',
      primaryColor:         '#1a2e1a',
      primaryBorderColor:   '#4caf50',
      primaryTextColor:     '#e8f5e9',
      secondaryColor:       '#0d1a0d',
      secondaryBorderColor: '#2d5a2d',
      secondaryTextColor:   '#8aab8a',
      tertiaryColor:        '#111711',
      tertiaryBorderColor:  '#2d5a2d',
      tertiaryTextColor:    '#8aab8a',
      noteBkgColor:         '#1a2e1a',
      noteTextColor:        '#e8f5e9',
      noteBorderColor:      '#3a7a3a',
      activationBkgColor:   '#1a2e1a',
      activationBorderColor:'#4caf50',
      actorBkg:             '#161e16',
      actorBorder:          '#4caf50',
      actorTextColor:       '#e8f5e9',
      actorLineColor:       '#3a7a3a',
      signalColor:          '#4caf50',
      signalTextColor:      '#e8f5e9',
      labelBoxBkgColor:     '#111711',
      labelBoxBorderColor:  '#2d5a2d',
      labelTextColor:       '#8aab8a',
      loopTextColor:        '#8aab8a',
      altSectionBkgColor:   '#0d160d',
      fontFamily:           '-apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif',
      fontSize:             '14px'
    }
  });
</script>
</body>
</html>
